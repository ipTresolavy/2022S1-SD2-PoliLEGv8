DEPTH = 65535;
WIDTH = 8;

ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;
CONTENT
BEGIN
000 : 11010010;
001 : 10000000;
002 : 00000010;
003 : 10010011; -- MOVZ X19, 20, LSL 0
004 : 10001011;
005 : 00011111;
006 : 00000011;
007 : 11110001; -- MOV X17, XZR // keep (previous) 0 in X17 for further use
008 : 10010001;
009 : 00000000;
010 : 00000111;
011 : 11110010; -- ADDI X18, XZR, #1  // keep (Current) 1 in X18 for further use
012 : 10010001;
013 : 00000000;
014 : 00000011;
015 : 11101001; -- ADDI X9, XZR, #0  // Assuming i = 0 is in register X9
016 : 11010001;
017 : 00000000;
018 : 01100011;
019 : 10011100; -- fibo: SUBI SP, SP, #24 // Adjust stack pointer for 3 items
020 : 11111000;
021 : 00000001;
022 : 00000011;
023 : 10011110; -- STUR LR, [SP, #16] // save the return address
024 : 11111000;
025 : 00000000;
026 : 10000011;
027 : 10010001; -- STUR X17, [SP, #8] //save content of X17 on the stack
028 : 11111000;
029 : 00000000;
030 : 00000011;
031 : 10010010; -- STUR X18, [SP, #0] //save content of X18 on the stack
032 : 11101011;
033 : 00010011;
034 : 00000001;
035 : 00101010; -- SUBS   X10, X9, X19 // test for i==n
036 : 10110101;
037 : 00000000;
038 : 00000001;
039 : 00001010; -- CBNZ X10, L1 // If i not equal to n, go to L1
040 : 10001011;
041 : 00011111;
042 : 00000011;
043 : 11100110; -- MOV X6, XZR // keep 0 on X6
044 : 10010001;
045 : 00000000;
046 : 00000111;
047 : 11100101; -- ADDI X5, XZR, #1 // keep 1 on X5
048 : 10010001;
049 : 00000000;
050 : 00000101;
051 : 00100010; -- ADDI X2, X9, #1 //X9 increased by 1 for further use
052 : 11111000;
053 : 00000000;
054 : 00000010;
055 : 10000110; -- STUR X6, [X20,#0] //store 0 in the array
056 : 11111000;
057 : 00000000;
058 : 10000010;
059 : 10000101; -- STUR X5, [X20, #8] //store 1 in the array
060 : 10010001;
061 : 00000000;
062 : 01100011;
063 : 10011100; -- ADDI SP, SP, #24 // pop 3 items from the stack
064 : 11010110;
065 : 00011111;
066 : 00000011;
067 : 11111110; -- BR LR // return to the caller
068 : 10001011;
069 : 00010010;
070 : 00000010;
071 : 00110000; -- L1: ADD X16, X17, X18 // Next_Num = previous + Current
072 : 10001011;
073 : 00011111;
074 : 00000010;
075 : 01010001; -- MOV X17, X18 // Previous = Current
076 : 10001011;
077 : 00011111;
078 : 00000010;
079 : 00010010; -- MOV X18, X16 // Current= Next_Num
080 : 10010001;
081 : 00000000;
082 : 00000101;
083 : 00101001; -- ADDI X9, X9, #1 // i++
084 : 10010100;
085 : 00000000;
086 : 00000000;
087 : 00000100; -- BL fibo // call fibo
088 : 11111000;
089 : 01000000;
090 : 00000011;
091 : 10010010; -- LDUR X18, [SP, #0] // return from BL; restore previous
092 : 11111000;
093 : 01000000;
094 : 10000011;
095 : 10010001; -- LDUR X17, [SP, #8] // restore current
096 : 11111000;
097 : 01000001;
098 : 00000011;
099 : 10011110; -- LDUR LR, [SP, #16] // restore the return address
100 : 10010001;
101 : 00000000;
102 : 01100011;
103 : 10011100; -- ADDI SP, SP, #24 // adjust stack pointer to pop 3 items
104 : 10001011;
105 : 00010001;
106 : 00000010;
107 : 01000111; -- ADD X7, X18, X17 // keep (previous+current) value on register X7
108 : 11010011;
109 : 01111111;
110 : 00001100;
111 : 01000010; -- LSL X2, X2, #3 // Multiplying by 8 for offset
112 : 10001011;
113 : 00000010;
114 : 00000010;
115 : 10001100; -- ADD X12, X20, X2 // address of the array increase by 8
116 : 11111000;
117 : 00000000;
118 : 00000001;
119 : 10000111; -- STUR X7, [X12, #0] // store (previous + current) value on the array
120 : 11010001;
121 : 00000000;
122 : 00000100;
123 : 01000010; -- SUBI X2, X2, #1 // X9 decreased by 1
124 : 11010110;
125 : 00011111;
126 : 00000011;
127 : 11111110; -- BR LR // return
END;
